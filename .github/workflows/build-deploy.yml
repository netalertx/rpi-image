name: Build NetAlertX RPi Images

# -------------------------------------------------------------------------------------------------
# DUAL-MODE WORKFLOW DOCUMENTATION
#
# 1. REMOTE EXECUTION (GitHub Actions):
#    - Job: 'build'
#      - Builds the disk image.
#      - Generates 'fragment_*.json' with https://github.com/... download URLs.
#      - Uploads artifacts (image + json) to GitHub Storage.
#    - Job: 'release'
#      - Downloads artifacts.
#      - Merges fragments into 'repo.json'.
#      - Commits 'repo.json' to the repository.
#      - Creates a GitHub Release with the images.
#
# 2. LOCAL EXECUTION (via 'act' & .devcontainer/scripts/build_local_dev.sh):
#    - Job: 'build'
#      - Runs inside a local container.
#      - Detects 'env.ACT=true' (injected by 'act').
#      - Generates 'fragment_*.json' with file://... placeholder URLs.
#      - 'act' saves artifacts to a local temp directory (e.g., /tmp/artifacts).
#    - Job: 'release'
#      - SKIPPED (guarded by 'if: !is_act').
#    - Post-Process (Shell Script):
#      - The local script 'build_local_dev.sh' picks up the artifacts.
#      - It generates the final local 'repo.json'.
# -------------------------------------------------------------------------------------------------

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    name: Build ${{ matrix.variant }}
    runs-on: ubuntu-latest
    outputs:
      is_act: ${{ steps.check_env.outputs.is_act }}
    strategy:
      fail-fast: false
      matrix:
        variant: [prod, dev]
    
    # Permissions: 'contents: write' is primarily needed for the 'release' job (to push tags/commits).
    # It is kept here in 'build' for consistency/safety, though 'build' mostly just reads.
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Differentiate between Local ('act') and Remote (GitHub) environments
      - name: Check Environment
        id: check_env
        run: |
          if [ "${{ env.ACT }}" = "true" ]; then
            echo "is_act=true" >> $GITHUB_OUTPUT
          else
            echo "is_act=false" >> $GITHUB_OUTPUT
          fi

      - name: Set Variables
        id: vars
        run: |
          VARIANT="${{ matrix.variant }}"
          TS=$(date +%Y-%m-%d)
          TS_FILE=$(date +%Y-%m-%d_%H-%M-%S)
          
          if [ "$VARIANT" == "prod" ]; then
            IMAGE="jokobsk/netalertx:latest"
            NAME_SUFFIX=""
          else
            IMAGE="ghcr.io/netalertx/netalertx-dev:latest"
            NAME_SUFFIX=" (Dev)"
          fi

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_INFO="(PR #${{ github.event.number }})"
          else
            PR_INFO=""
          fi
          
          echo "variant=$VARIANT" >> $GITHUB_OUTPUT
          echo "timestamp=$TS" >> $GITHUB_OUTPUT
          echo "timestamp_file=$TS_FILE" >> $GITHUB_OUTPUT
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "name_suffix=$NAME_SUFFIX" >> $GITHUB_OUTPUT
          echo "pr_info=$PR_INFO" >> $GITHUB_OUTPUT

      - name: Install dependencies
        run: |
          sudo apt-get update -q
          sudo apt-get install -yq qemu-user-static binfmt-support wget unzip parted jq

      - name: Prepare Official Base Image
        run: |
          rm -f rpi.img rpi.img.xz
          BASE_URL="https://downloads.raspberrypi.org/raspios_lite_arm64/images/"
          LATEST_DIR=$(curl -sL "$BASE_URL" | grep -o 'href="raspios_lite_arm64-[0-9-]*\/"' | cut -d'"' -f2 | sort | tail -n 1)
          IMAGE_FILENAME=$(curl -sL "${BASE_URL}${LATEST_DIR}" | grep -o 'href="[^"]*\.img\.xz"' | head -1 | cut -d'"' -f2)
          URL="${BASE_URL}${LATEST_DIR}${IMAGE_FILENAME}"
          wget -q -O rpi.img.xz "$URL"
          unxz -f rpi.img.xz
          truncate -s +1200M rpi.img
          parted rpi.img resizepart 2 100%
          for i in {0..255}; do [ ! -e /dev/loop$i ] && sudo mknod /dev/loop$i b 7 $i; done
          LOOP=$(sudo losetup -fP --show rpi.img)
          echo "LOOP_DEV=$LOOP" >> $GITHUB_ENV
          LOOP_NAME=$(basename $LOOP)
          for part in /sys/block/$LOOP_NAME/${LOOP_NAME}p*; do
            if [ -d "$part" ]; then
              PART_NAME=$(basename $part)
              if [ ! -e /dev/$PART_NAME ]; then
                MAJMIN=$(cat $part/dev)
                sudo mknod /dev/$PART_NAME b ${MAJMIN%:*} ${MAJMIN#*:} 
              fi
            fi
          done
          sudo e2fsck -fp "${LOOP}p2"
          sudo resize2fs "${LOOP}p2"

      - name: Mount Filesystem & Inject Configs
        run: |
          mkdir -p target
          sudo mount "${{ env.LOOP_DEV }}p2" target
          sudo mount "${{ env.LOOP_DEV }}p1" target/boot/firmware
          sudo cp /usr/bin/qemu-aarch64-static target/usr/bin/
          sudo mount --bind /dev target/dev
          sudo mount --bind /proc target/proc
          sudo mount --bind /sys target/sys
          sudo cp -r root_filesystem/* target/

      - name: Pre-load Docker Image
        run: |
          docker pull --platform linux/arm64 ${{ steps.vars.outputs.image }}
          docker save ${{ steps.vars.outputs.image }} -o netalertx_image.tar
          DIND_ID=$(docker run --privileged -d docker:dind --storage-driver overlay2)
          until docker exec $DIND_ID docker info >/dev/null 2>&1; do sleep 1; done
          docker cp netalertx_image.tar $DIND_ID:/img.tar
          docker exec $DIND_ID docker load -i /img.tar
          sudo rm -rf target/var/lib/docker
          sudo mkdir -p target/var/lib/docker
          docker exec $DIND_ID tar -C /var/lib/docker -cf - . | sudo tar -C target/var/lib/docker -xf - 
          docker stop $DIND_ID && docker rm $DIND_ID
          rm netalertx_image.tar

      - name: Install Packages & Services (Chroot)
        run: |
          sudo chroot target /bin/bash << 'CHROOT'
            export DEBIAN_FRONTEND=noninteractive
            apt-get update -q
            apt-get install -yq ca-certificates curl gnupg
            install -m 0755 -d /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            echo "deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian bookworm stable" > /etc/apt/sources.list.d/docker.list
            apt-get update -q
            apt-get install -yq --no-install-recommends docker-ce docker-ce-cli containerd.io docker-compose-plugin
            systemctl enable docker netalertx-updater.timer netalertx
          CHROOT

      - name: Configure NetAlertX
        run: |
          sudo sed -i "s|ghcr.io/netalertx/netalertx-dev:latest|${{ steps.vars.outputs.image }}|g" target/opt/netalertx/docker-compose.yml

      - name: Cleanup & Compress
        run: |
          sudo umount -l target/boot/firmware || true
          sudo umount -l target/dev || true
          sudo umount -l target/proc || true
          sudo umount -l target/sys || true
          sudo umount -lR target || true
          sleep 1
          sudo losetup -d ${{ env.LOOP_DEV }} || true
          EXTRACT_SIZE=$(stat -c%s rpi.img)
          EXTRACT_SHA256=$(sha256sum rpi.img | awk '{print $1}')
          xz -v -9 -T 0 rpi.img
          IMG_FILENAME="netalertx-rpi-${{ steps.vars.outputs.variant }}-${{ steps.vars.outputs.timestamp_file }}.img.xz"
          mv rpi.img.xz $IMG_FILENAME
          DOWNLOAD_SIZE=$(stat -c%s $IMG_FILENAME)
          DOWNLOAD_SHA256=$(sha256sum $IMG_FILENAME | awk '{print $1}')
          
          # ---------------------------------------------------------------------
          # URL GENERATION:
          # Local (ACT): Uses 'file://' with a placeholder path for local testing.
          # Remote: Uses standard GitHub Releases URL.
          # ---------------------------------------------------------------------
          if [ "${{ env.ACT }}" == "true" ]; then
            DOWNLOAD_URL="file://__LOCAL_PATH__/netalertx-rpi-image-dev/$IMG_FILENAME"
            NAME_ENV=" (LOCAL)"
          else
            DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/__RELEASE_TAG__/$IMG_FILENAME"
            NAME_ENV=""
          fi
          
          jq -n \
            --arg name "NetAlertX${{ steps.vars.outputs.name_suffix }}${NAME_ENV} ${{ steps.vars.outputs.pr_info }}" \
            --arg desc "NetAlertX ${{ matrix.variant }} Build (${{ steps.vars.outputs.timestamp }})." \
            --arg date "${{ steps.vars.outputs.timestamp }}" \
            --arg url "$DOWNLOAD_URL" \
            --argjson dl_size $DOWNLOAD_SIZE \
            --arg dl_sha "$DOWNLOAD_SHA256" \
            --argjson ex_size $EXTRACT_SIZE \
            --arg ex_sha "$EXTRACT_SHA256" \
            '{ 
              name: $name,
              description: $desc,
              icon: "https://raw.githubusercontent.com/netalertx/NetAlertX/refs/heads/main/docs/img/NetAlertX_logo.png",
              release_date: $date,
              url: $url,
              image_download_size: $dl_size,
              image_download_sha256: $dl_sha,
              extract_size: $ex_size,
              extract_sha256: $ex_sha,
              init_format: "cloudinit-rpi",
              devices: ["pi5-64bit", "pi4-64bit", "pi3-64bit", "pi02w-64bit"],
              capabilities: ["rpi_connect"]
            }' > "fragment_${{ matrix.variant }}.json"

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.variant }}
          path: |
            *.img.xz
            fragment_*.json

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    # -------------------------------------------------------------------------
    # REMOTE ONLY: This job is skipped in local 'act' runs.
    # It aggregates artifacts, commits 'repo.json', and publishes the release.
    # -------------------------------------------------------------------------
    if: ${{ needs.build.outputs.is_act != 'true' }}
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: Set Release Variables
        id: vars
        run: |
          TS_FILE=$(date +%Y-%m-%d_%H-%M-%S)
          echo "tag_name=rel-$TS_FILE" >> $GITHUB_OUTPUT

      - name: Merge Repository JSONs
        run: |
          echo "Merging JSON fragments..."
          jq -n '{os_list: [inputs]}' artifacts/fragment_prod.json artifacts/fragment_dev.json \
            | sed "s/__RELEASE_TAG__/${{ steps.vars.outputs.tag_name }}/g" > repo.json
          
          # Cleanup fragments
          rm artifacts/fragment_*.json

      - name: Commit and Push repo.json
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add repo.json
          git commit -m "chore: update repo.json for release ${{ steps.vars.outputs.tag_name }}"
          git push

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            artifacts/*.img.xz
          tag_name: ${{ steps.vars.outputs.tag_name }}
          name: NetAlertX RPi Images ${{ steps.vars.outputs.tag_name }}
          prerelease: true
          body: |
            Automated NetAlertX Raspberry Pi Image Release.
            
            **Installation:**
            Use Raspberry Pi Imager and select `repo.json` (URL).